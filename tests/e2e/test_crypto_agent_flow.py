"""End-to-End Test for Crypto Agent Workflow.

This test simulates the full agent lifecycle:
1. Factor Generation (via Qlib FactorEngine)
2. Signal Conversion (via SignalConverter)
3. Strategy Backtest (via CryptoQlibBacktest)

It verifies that all components integrate correctly using:
- Real Qlib binary data (generated by verify_qlib_data.py)
- Real Qlib C++ expression engine
- Real Crypto settlement logic (funding/liquidation)
"""

import os
import shutil
import pytest
import pandas as pd
import numpy as np
from pathlib import Path

# Import core components
from iqfmp.core.factor_engine import QlibFactorEngine
from iqfmp.core.signal_converter import SignalConverter, SignalConfig
from iqfmp.core.crypto_backtest import CryptoQlibBacktest, CryptoBacktestConfig

# Test constants
DATA_DIR = Path("data/qlib_data_verify")
SYMBOL = "ethusdt"  # Lowercase for Qlib
FACTOR_EXPR = "Mean($close, 5) / $close - 1"  # Simple mean reversion

@pytest.fixture(scope="module")
def qlib_init():
    """Initialize Qlib with local data."""
    import qlib
    if not DATA_DIR.exists():
        pytest.skip(f"Data directory {DATA_DIR} not found. Run scripts/verify_qlib_data.py first.")
    
    # Initialize Qlib
    qlib.init(provider_uri=str(DATA_DIR.absolute()))
    return True

def test_full_agent_workflow(qlib_init):
    """Test the complete flow from factor to backtest."""
    print("\n" + "="*60)
    print("üöÄ Starting Crypto Agent Workflow E2E Test")
    print("="*60)

    # ---------------------------------------------------------
    # Step 1: Factor Generation (Factor Agent)
    # ---------------------------------------------------------
    print("\n[Step 1] Factor Generation...")
    engine = QlibFactorEngine(
        provider_uri=str(DATA_DIR.absolute()),
        instruments=[SYMBOL],
        symbol=SYMBOL
    )
    
    # Enable D.features path for C++ engine usage
    engine.enable_d_features(True)
    
    # Compute factor
    factor_values = engine.compute_factor(
        expression=FACTOR_EXPR,
        factor_name="mean_reversion_5d",
        start_time="2022-01-01",
        end_time="2025-12-31"
    )
    
    print(f"‚úÖ Factor computed: {len(factor_values)} rows")
    print(f"   Head: {factor_values.head(3).to_dict()}")
    
    assert len(factor_values) > 0, "Factor computation returned empty result"
    assert not factor_values.isna().all(), "Factor values are all NaN"

    # ---------------------------------------------------------
    # Step 2: Signal Conversion (Orchestrator)
    # ---------------------------------------------------------
    print("\n[Step 2] Signal Conversion...")
    converter = SignalConverter(SignalConfig(
        normalize_method="zscore",
        signal_threshold=1.0,  # Long > 1 std, Short < -1 std
        max_position=1.0
    ))
    
    signal = converter.to_signal(factor_values)
    print(f"‚úÖ Signal generated: {len(signal)} rows")
    print(f"   Non-zero signals: {(signal != 0).sum()}")
    
    # Slice signal for the specific symbol if MultiIndex
    if isinstance(signal.index, pd.MultiIndex):
        try:
            signal = signal.loc[SYMBOL]
            print(f"   Sliced signal for {SYMBOL}, new shape: {signal.shape}")
        except KeyError:
            print(f"   Warning: Symbol {SYMBOL} not found in signal index")
            signal = signal.droplevel(0)
    
    assert len(signal) == len(factor_values) if isinstance(factor_values.index, pd.Index) else True

    # ---------------------------------------------------------
    # Step 3: Data Preparation for Backtest
    # ---------------------------------------------------------
    # We need OHLCV + Funding Rate for the backtest engine
    # Load it via Qlib D.features to ensure alignment
    from qlib.data import D
    price_data = D.features(
        instruments=[SYMBOL],
        fields=["$close", "$open", "$high", "$low", "$volume", "$funding_rate"],
        start_time="2022-01-01",
        end_time="2025-12-31"
    )
    
    # Rename columns to match backtest engine requirements (remove $ prefix)
    price_data.columns = [c.replace("$", "") for c in price_data.columns]
    
    # Qlib D.features returns MultiIndex (instrument, datetime)
    # We need to slice it for the specific symbol to get DatetimeIndex
    print(f"   D.features shape: {price_data.shape}")
    print(f"   Index type: {type(price_data.index)}")
    
    if isinstance(price_data.index, pd.MultiIndex):
        try:
            price_data = price_data.loc[SYMBOL]
            print(f"   Sliced for {SYMBOL}, new shape: {price_data.shape}")
        except KeyError:
            # Fallback if symbol casing mismatch
            print(f"   Warning: Symbol {SYMBOL} not found in index {price_data.index.get_level_values(0).unique()}")
            price_data = price_data.droplevel(0)
    
    # Check if we have funding rate data (might be missing in sample)
    if "funding_rate" not in price_data.columns:
        print("‚ö†Ô∏è  Funding rate missing, adding dummy zeros")
        price_data["funding_rate"] = 0.0
    else:
        # Fill NaN funding rates
        price_data["funding_rate"] = price_data["funding_rate"].fillna(0.0)

    # ---------------------------------------------------------
    # Step 4: Backtest Execution (Strategy Agent)
    # ---------------------------------------------------------
    print("\n[Step 4] Strategy Backtest...")
    config = CryptoBacktestConfig(
        initial_capital=100_000.0,
        leverage=1,
        commission_rate=0.0005,
        slippage_rate=0.0001,
        funding_enabled=True
    )
    
    backtest_engine = CryptoQlibBacktest(config, [SYMBOL])
    
    # Align signal with price data
    signal_aligned = signal.reindex(price_data.index).fillna(0)
    
    result = backtest_engine.run(
        data=price_data,
        signals=signal_aligned,
        symbol=SYMBOL
    )
    
    print("\nüìä Backtest Results:")
    print(f"   Total Return: {result.total_return:.2%}")
    print(f"   Sharpe Ratio: {result.sharpe_ratio:.2f}")
    print(f"   Max Drawdown: {result.max_drawdown:.2%}")
    print(f"   Trades: {result.n_trades}")
    
    # ---------------------------------------------------------
    # Step 5: Assertions
    # ---------------------------------------------------------
    assert result.total_return != 0, "Backtest returned 0 return (did it run?)"
    assert result.n_trades > 0, "No trades executed"
    assert len(result.equity_curve) == len(price_data), "Equity curve length mismatch"
    
    print("\n‚úÖ E2E Workflow Test Passed!")

if __name__ == "__main__":
    # Manually run if executed as script
    try:
        class MockQlib: pass
        qlib_fixture = MockQlib()
        test_full_agent_workflow(qlib_fixture)
    except Exception as e:
        print(f"\n‚ùå Test Failed: {e}")
        import traceback
        traceback.print_exc()
