"""Factor Code Validator for IQFMP.

Validates LLM-generated factor code for:
- Syntax correctness
- Required function signature
- Allowed data fields
- Security compliance

This validator ensures that factor code generated by LLM agents
is safe to execute and follows the expected conventions.
"""

import ast
import re
from dataclasses import dataclass, field
from typing import Optional, Set


@dataclass
class ValidationResult:
    """Result of factor code validation."""

    is_valid: bool
    errors: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)
    required_fields: set[str] = field(default_factory=set)

    def to_dict(self) -> dict:
        return {
            "is_valid": self.is_valid,
            "errors": self.errors,
            "warnings": self.warnings,
            "required_fields": list(self.required_fields),
        }


class FactorCodeValidator:
    """Validates factor code before execution.

    This validator performs static analysis on factor code to ensure:
    1. Valid Python syntax
    2. Correct function signature (def factor_name(df: pd.DataFrame) -> pd.Series)
    3. Only allowed data fields are accessed
    4. No forbidden/dangerous operations

    Example:
        validator = FactorCodeValidator()
        result = validator.validate(code, "my_factor")
        if not result.is_valid:
            print("Errors:", result.errors)
    """

    # Standard OHLCV fields
    BASIC_FIELDS = {"open", "high", "low", "close", "volume"}

    # Crypto-specific fields
    CRYPTO_FIELDS = {
        "funding_rate",
        "funding_rate_predicted",
        "open_interest",
        "open_interest_change",
        "basis",
        "premium",
        "mark_price",
        "index_price",
        "liquidation_volume",
        "long_ratio",
        "short_ratio",
    }

    # Orderbook fields
    ORDERBOOK_FIELDS = {
        "bid_volume",
        "ask_volume",
        "spread",
        "bid_ask_imbalance",
        "depth_imbalance",
    }

    # On-chain fields
    ONCHAIN_FIELDS = {
        "whale_flow",
        "exchange_reserve",
        "active_addresses",
        "transaction_count",
        "nvt_ratio",
    }

    # Technical indicator fields (pre-computed)
    INDICATOR_FIELDS = {
        "rsi_14",
        "macd",
        "macd_signal",
        "macd_hist",
        "bb_upper",
        "bb_lower",
        "atr_14",
        "ema_12",
        "ema_26",
        "sma_20",
    }

    # Qlib-style fields with $ prefix
    QLIB_FIELDS = {f"${f}" for f in BASIC_FIELDS | CRYPTO_FIELDS | INDICATOR_FIELDS}

    # All allowed fields
    ALLOWED_FIELDS: Set[str] = (
        BASIC_FIELDS
        | CRYPTO_FIELDS
        | ORDERBOOK_FIELDS
        | ONCHAIN_FIELDS
        | INDICATOR_FIELDS
        | QLIB_FIELDS
    )

    # Forbidden operations (security risk)
    FORBIDDEN_OPS = {
        "open",
        "exec",
        "eval",
        "__import__",
        "compile",
        "globals",
        "locals",
        "vars",
        "dir",
        "getattr",
        "setattr",
        "delattr",
        "input",
        "breakpoint",
    }

    # Forbidden imports (security risk)
    FORBIDDEN_IMPORTS = {
        "os",
        "sys",
        "subprocess",
        "shutil",
        "socket",
        "requests",
        "urllib",
        "http",
        "ftplib",
        "smtplib",
        "pickle",
        "marshal",
        "shelve",
        "tempfile",
        "pathlib",
        "glob",
        "importlib",
    }

    # Allowed imports
    ALLOWED_IMPORTS = {
        "numpy",
        "np",
        "pandas",
        "pd",
        "scipy",
        "scipy.stats",
        "talib",
        "math",
        "datetime",
        "typing",
    }

    def __init__(self, strict_mode: bool = False):
        """Initialize validator.

        Args:
            strict_mode: If True, treat warnings as errors
        """
        self.strict_mode = strict_mode

    def validate(
        self, code: str, factor_name: str, expected_args: int = 1
    ) -> ValidationResult:
        """Validate factor code.

        Args:
            code: Factor code string
            factor_name: Expected factor function name
            expected_args: Expected number of function arguments

        Returns:
            ValidationResult
        """
        errors = []
        warnings = []
        required_fields: set[str] = set()

        # 1. Syntax check
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            return ValidationResult(
                is_valid=False,
                errors=[f"Syntax error at line {e.lineno}: {e.msg}"],
                warnings=[],
            )

        # 2. Check function definition
        func_found = False
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                if node.name == factor_name:
                    func_found = True
                    # Check arguments
                    n_args = len(node.args.args)
                    if n_args != expected_args:
                        errors.append(
                            f"Function must have exactly {expected_args} argument(s), got {n_args}"
                        )
                    elif n_args > 0 and node.args.args[0].arg not in ("df", "data"):
                        warnings.append(
                            f"First argument should be named 'df' or 'data', got '{node.args.args[0].arg}'"
                        )

                    # Check for type annotations (recommended)
                    if not node.args.args[0].annotation:
                        warnings.append(
                            "Missing type annotation for input parameter (recommend: pd.DataFrame)"
                        )
                    if not node.returns:
                        warnings.append(
                            "Missing return type annotation (recommend: pd.Series)"
                        )

        if not func_found:
            errors.append(f"Function '{factor_name}' not found in code")

        # 3. Check for forbidden operations
        for node in ast.walk(tree):
            if isinstance(node, ast.Name):
                if node.id in self.FORBIDDEN_OPS:
                    errors.append(f"Forbidden operation: {node.id}")

            if isinstance(node, ast.Import):
                for alias in node.names:
                    module_name = alias.name.split(".")[0]
                    if module_name in self.FORBIDDEN_IMPORTS:
                        errors.append(f"Forbidden import: {alias.name}")
                    elif module_name not in self.ALLOWED_IMPORTS:
                        warnings.append(f"Unusual import: {alias.name}")

            if isinstance(node, ast.ImportFrom):
                if node.module:
                    module_name = node.module.split(".")[0]
                    if module_name in self.FORBIDDEN_IMPORTS:
                        errors.append(f"Forbidden import from: {node.module}")

            # Check for calls to dangerous functions
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    if node.func.id in self.FORBIDDEN_OPS:
                        errors.append(f"Forbidden function call: {node.func.id}")

        # 4. Extract and validate data field usage
        required_fields = self._extract_fields(tree)

        unknown_fields = required_fields - self.ALLOWED_FIELDS
        if unknown_fields:
            for field in unknown_fields:
                # Only warn for truly unknown fields, not common pandas operations
                if not self._is_common_pandas_attr(field):
                    warnings.append(f"Unknown data field: {field}")

        if not required_fields:
            warnings.append("No data fields detected in code")

        # 5. Check for common anti-patterns
        anti_patterns = self._check_anti_patterns(tree)
        warnings.extend(anti_patterns)

        # In strict mode, treat warnings as errors
        if self.strict_mode:
            errors.extend(warnings)
            warnings = []

        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
            required_fields=required_fields,
        )

    def _extract_fields(self, tree: ast.AST) -> set[str]:
        """Extract data fields required by factor code.

        Args:
            tree: AST tree

        Returns:
            Set of required field names
        """
        fields = set()

        for node in ast.walk(tree):
            # df["field"] or df['field']
            if isinstance(node, ast.Subscript):
                if isinstance(node.slice, ast.Constant):
                    field = node.slice.value
                    if isinstance(field, str):
                        fields.add(field)
                # For older Python: df["field"]
                elif isinstance(node.slice, ast.Index):  # type: ignore
                    if hasattr(node.slice, "value") and isinstance(
                        node.slice.value, ast.Constant  # type: ignore
                    ):
                        fields.add(node.slice.value.value)  # type: ignore

            # df.field (attribute access)
            if isinstance(node, ast.Attribute):
                if isinstance(node.value, ast.Name):
                    if node.value.id in ("df", "data"):
                        fields.add(node.attr)

        return fields

    def _is_common_pandas_attr(self, name: str) -> bool:
        """Check if name is a common pandas attribute/method."""
        common_attrs = {
            "rolling",
            "ewm",
            "shift",
            "diff",
            "pct_change",
            "mean",
            "std",
            "sum",
            "min",
            "max",
            "median",
            "quantile",
            "rank",
            "cumsum",
            "cumprod",
            "cummax",
            "cummin",
            "fillna",
            "dropna",
            "apply",
            "map",
            "abs",
            "clip",
            "iloc",
            "loc",
            "head",
            "tail",
            "values",
            "index",
            "columns",
            "shape",
        }
        return name in common_attrs

    def _check_anti_patterns(self, tree: ast.AST) -> list[str]:
        """Check for common anti-patterns in factor code."""
        warnings = []

        for node in ast.walk(tree):
            # Check for hardcoded lookback periods without parameters
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Attribute):
                    if node.func.attr == "rolling":
                        # Check if using hardcoded magic number
                        for arg in node.args:
                            if isinstance(arg, ast.Constant):
                                if isinstance(arg.value, int) and arg.value > 100:
                                    warnings.append(
                                        f"Large hardcoded lookback period: {arg.value}"
                                    )

            # Check for potential look-ahead bias
            if isinstance(node, ast.Subscript):
                if isinstance(node.slice, ast.UnaryOp):
                    if isinstance(node.slice.op, ast.USub):
                        # Negative indexing might indicate look-ahead
                        pass  # This is usually OK for lookback

        return warnings

    def extract_required_fields(self, code: str) -> set[str]:
        """Extract data fields required by factor code.

        Args:
            code: Factor code string

        Returns:
            Set of required field names
        """
        try:
            tree = ast.parse(code)
        except SyntaxError:
            return set()

        return self._extract_fields(tree)

    def sanitize_code(self, code: str) -> str:
        """Sanitize factor code by removing dangerous patterns.

        Args:
            code: Raw factor code

        Returns:
            Sanitized code string
        """
        # Remove any shell escape attempts
        code = re.sub(r"!\s*[a-z]+", "", code)

        # Remove obvious injection patterns
        dangerous_patterns = [
            r"__\w+__",  # Dunder attributes
            r"eval\s*\(",
            r"exec\s*\(",
            r"compile\s*\(",
            r"import\s+os",
            r"import\s+sys",
            r"from\s+os",
            r"from\s+sys",
        ]

        for pattern in dangerous_patterns:
            code = re.sub(pattern, "# REMOVED: unsafe pattern", code)

        return code


def create_factor_validator(strict: bool = False) -> FactorCodeValidator:
    """Factory function to create a FactorCodeValidator.

    Args:
        strict: If True, treat warnings as errors

    Returns:
        Configured FactorCodeValidator
    """
    return FactorCodeValidator(strict_mode=strict)
